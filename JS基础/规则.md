# 1.js基本数据类型转换

* 转number类型 :

  * 1.number方法:
    * string类型转number类型 : 如果转换类型里有非数字,那么就会转成NaN  undefined Null 也是一样
    * boolean转成number : true:1;  false:0;
  * 2.parseInt方法:只会保留整数 ,返回整数部分;转成功的话,只能传入有数字部分在前面的字符串, 如果传入其他类型则是NaN;
  * 3.parseFloat方法:返回值会保留小数部分;转成功的话,只能传入有数字部分在前面的字符串,传入其他类型也是NaN;

* 转string类型 :

  * 1.String():先把右侧进行加工，把右侧的结果赋值给左侧；

  * 2.toString(): 数据或者变量.toString(); 注意：undefined和null不能使用这个方式变成字符串;

* 转booleanl类型 : 

  * String类型所有内容都转成true,空格也是;出了空标签(false);
  * number类型所有内容都转成true,除了NaN和0(false);
  * undefined和Null都是false

# 2.运算符

* 算术运算符：
  * **规则：字符串遇见+：左右两边数据类型转换为是string类型，形成字符串拼接；**
  * **++ 规则：**（面试）
  * 如果遇见++写在a的后面，先把自己的数推到位置上，在进行a++运算（运算后结果不推到位置上）
  * 如果遇见++写在a前面，++a先算，计算后的结果，再往位置上提供数据；

* 比较运算符：
  * **==规则：**
    * 数量类型不同的时候，不同的类型要隐式转化为Number类型，再去比值；
    * 数量类型相同的时候，直接比值的是否相等；
  * **===规则：如果数据类型不同，直接返回false;**
* 逻辑：
  * && ||：
    * 比较过程：只是进行比较，不进行返回；
    * 全部满足，如果有一个不满足的话，返回不满足位置上的数据；
* !：Boolean值取反；
  * !a；（a此时为变量）

# 3.分支结构及循环结构

* 分支结构if-else

  * 作用: 不同的情况,走不同的分支;
  * 特点: 一组分支,只要进入其中的一个分支,其他的分支都不会执行;

* 分支结构switch-case

  * 场景：变量与多个固定值进行  === 比较判断；
  * 注意（了解）：（非常规操作）case里面的break不是必须的，但是如果没有break,会继续往下执行；直到遇到下一个break;

* 分支结构-三元表达式 : 

  * 三元表达式: if-else的简写;有返回值,       表达式1?表达式2: 表示式3;

  * 过程: 如果表达式1的结果为true,则执行表达式2,结果为false,执行表达式3

    max = a > b ? a : b;

      alert(max);

* 循环结构while
  * 作用: 有重复的思想在里面,有规律的变化,循环重复
  * 特点: ()内condition：条件表达式，返回Boolean值；不是个Boolean值，隐式转化为Boolean；
    * 条件表达式返回一直true，循环体每次到要执行；死循环
    * 反回false，不行执行循环体，后面循环执行终止



* 循环结构for

  * for(初始化表达式;条件表达式;自增表达式) {
    	//循环体
    }
  * 注意：**里面的for 在  外面的for的循环体内部，那么外面的for 的每次执行，都会把 里面的for 重新执行一次；那么 var b = 1，在每次外面的for 的循环都会重新初始化；**

* 循环结构do-while

  * do {
    //循环体
      } while (false);

      //false至少会执行一次；true无限循环

* 循环结构break和continue

  * break : 终止当前循环;
  * continue : 跳过当次循环,本次代码不执行,继续往下一次执行;



# 4.数组

* 数据类型：数组,一个有长度,顺序,索引的数据集合,要管理大量的数据；
  *  object 复杂数据类型：和简单数据类型，在内存上存的位置不一样；
  *   var arr = [];

*  索引：位置，数字表示，从0开始；方便找数据，存数据，拿数据；
  * 数组的核心就是索引，拿到索引 下标（位置），拿到位置上数据,方便寻找和放入
  * 特点：最大索引总是比长度少 1 ；因为索引是从0（第一位）开始，

# 5.函数

- 函数：把一些**复用** 代码 **封装** 起来，在未来使用时 **调用**；
- 需求：函数里面的功能不能写成固定代码；变活；
- 核心：函数把代码分成 里面 和 外面；**里面和外面没有任何关系；**【规则】
- 参数：
  - 形参：函数内部的变量，只能在函数内部玩耍；函数的外面不能使用；即使外面的变量和内部的变量同名，也没有任何关系；
    - 内部的变量形式：形参，函数内部自己声明变量，arguments；
  - 实参：实际参与运算的数据，把实参的数据，赋值（复制）了一份给形参；
- 返回值：如果函数里面加工完的结果，外面需要，函数内部设置返回值   return 数据；
- 封装函数：是否搭两座桥？【重点】
  - 外面的数据 怎么 进入函数里面？参数；
  - 函数内部的数据是否需要 给到函数的外面？返回值；
- 作用域：
  - 里面：函数里面，局部作用域，局部的变量只能在局部作用域使用；
  - 外面：函数外面，全局作用域，可以在任意地方使用全局作用域的变量；
- 预解析：【重点】
  - 解析：内存，解析后才执行代码；
  - 规则：代码执行的时候，遇见一个新的作用域，预解析，把遇见的 var 变量；function 函数名(){} ,提升到**当前作用域的最顶端**

# 6.对象

* ：属性和方法（函数）的集合体
* 语法：
  * obj.key：key属性名；
  * obj[key]  key:变量，看变量后面存的值；
* 简单类型与复杂类型：【!!!面试 ，JS高级】
  * 内存上有两种空间，栈 堆； 只要var 变量，就要在栈上 开一个格子（栈空间）
  * 简单数据类型只能存入 栈上；
  * 复杂数据类型只能存入 堆上；

# 7.DOM

* this：看函数属于谁，this就是那个谁；如果在函数内部，你要使用 注册给哪个DOM节点。用this;