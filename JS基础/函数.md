# 01-函数-介绍-语法-调用

```js
  // 问题：(为什么)代码在某个地方，可能会重复出现；
  // 作用：代码在未来的jS某个部分可能会重复出现，函数将这部分重复出现的代码 封装（包）起来；在你需要的地方进行 调用（包起来的代码在用的地方使用）

  // 语法：
  // function:声明函数的关键字 
  function tell_story() {
    // 封装的代码；不会自己调用；
    console.log("从前有座山，山里有座庙");
    console.log("庙里有些 和尚");
    console.log("讲故事");
    console.log("老和尚对小和尚说：");
  }

  // 调用语法：函数名();
  tell_story();
```

* 注意：不要重名（变量名一样）；



# 02-函数-参数-配置

```js
  // 作用：把不同的主角的名字传入同一个故事套路，不让故事写死；
  // 语法：定义参数；参数是函数内部的变量(名字)，没有var,相当于有 var；定义的函数(参数)里面
  // 如何在内部使用：把你要替换的数据 换为 定义的参数（变量）；

  function tellStory(name1) {4                                                                                                                                                                                                                                                                              
    // 封装的代码；不会自己调用；
    console.log("从前有座山，山里有座庙");
    console.log("庙里有些人");
    console.log("讲故事");
    console.log(name1 + "对小和尚说：");
  }

 // 如何在外面使用：调用函数的时候，传入真实的数据；
  // 特点（规则）
  //   1. 内部的变量，参数，只能在内部使用；
  //   2. 外面传入真实的数据，把外面传入的真实数据，赋值(复制)了一份给 内部的参数；
  var a = "熊大"
  tellStory(a);
  // name1  = a;
```







# 03-函数-参数-不赋值

* 语法：
  * 多个参数；
  * 不赋值的优化；

```js
  // 
  // function tellStory(name1, name2) {
  //   // 封装的代码；不会自己调用；
  //   console.log("从前有座山，山里有座庙");
  //   console.log("庙里有些人");
  //   console.log("讲故事");
  //   console.log(name1 + "对" + name2 + "说：");
  // }

  // 个数：不固定个数，设置多少个都可以；
  // 语法：参数1,参数2,...
  // 外面：传入多个对应的真实数据；正常使用；

  // --------------------------------------------------
  // 外面：有可能不传入参数；
  // 语法：内部参数（变量），我们不赋值的话（我们没有传入真实数据）JS内置给赋值， undefined，
  // function fn(a) {
  //   console.log(a);
  // }

  // fn(); // 输出undefined

  function tellStory(name1, name2) {
    // 友好性，优化：不传入真实的数据，分支才生效；
    // if (name1 == undefined) {
    //   name1 = "大哥";
    // }

    
    // 三元表达式？现在不要求掌握
    // name1 = name1 == undefined ? "大哥" : name1;



    // 两种分支
    // if (name2 == undefined) {
    //   name2 = "二哥";
    // }
    // name2 = name2 == undefined ? "二哥" : name2;


    // 封装的代码；不会自己调用；
    console.log("从前有座山，山里有座庙");
    console.log("庙里有些人");
    console.log("讲故事");
    console.log(name1 + "对" + name2 + "说：");
  }

  tellStory();
```



# 04-函数-参数-形参与实参

```js
  // 形参：内部定义的这个变量，只能在内部使用；外面不能使用；和外面没有任何关系;
  // 实参：外部调用函数的时候，传入真实数据，实参；把真实数据赋值了一份给形参；
  // function tellStory(name1, name2) {
  //   // 封装的代码；不会自己调用；
  //   console.log("从前有座山，山里有座庙");
  //   console.log("庙里有些人");
  //   console.log("讲故事");
  //   console.log(name1 + "对" + name2 + "说：");
  // }

  // tellStory("a", "b");


  // 特点（规则）：形参与实参相互不影响；
  // 形参：外面不能使用；和外面没有任何关系;只能函数内部使用；
  // 实参：把实参的数据，赋值(复制)了一份给形参；

  function fn(a) {
    a = a + 10;
  }

  var a = 10;
  fn(a);
  // a = a;
  // 前面a:形参，只能在函数内部使用，和外面没有关系；
  // 后面a:实参，外面的实参把自己的值，赋值（复制）了给里面的形参a；
```



# 05-函数-返回值

* 形参，内部的变量，只能在内部使用；既然只能在内部使用，和外面没有关系，那么什么时候需要配置形参？
* 如果外面的数据需要给内部加工下，那就配置形参；实参传入真实数据；
* 加工完后，在函数内部，外面拿不到？
* 需要用返回值return  数据（变量）；

```js
  // 语法：返回值；
  // 作用：把内部运算结果，给到外面；
  function fn(a) {
    a = a + 10;
    // 内部：只能在函数内部使用，把变量后面真实数据返回出去;
    // 关键字：return；返回什么值外边接受什么值
    return 1;
  }
  // 外面：需要找个变量接受
  var b = fn(10);
  console.log(b);

  // 意义：把内部运算结果，返回给外面；
```

* 注意：

```js
// 特点（规则）：
//  1. 函数返回值，把内部的值进行返回，返回到外面；
//  2. 只要函数内部出现了return，函数内return下面的代码(函数内)不再执行；
//  3. 如果return 后面没有任何数据（变量）,默认返回undefined；
//  4. 如果连return都没有，函数就没有返回值，执行函数，默认返回undefined；


// 规则2:
function fn(a) {
    a = a + 10;
    // 内部：只能在函数内部使用，把变量后面真实数据返回出去;
    // 关键字：return；

    return a;
    // 函数内部 return下面的代码不再执行；
    console.log("--------------------------------------------");
}

// 规则3:
function fn() {
    return;
}
var a = fn();
console.log(a);

// 规则4：
function fn() {
    // return;
}
var a = fn();
console.log(a);
```





# 06-函数-案例-求n-m和

* 总结：
  * 函数：把一些**复用** 代码 **封装** 起来，在未来 **调用**；
  * 需求：函数里面的功能不能写成固定代码；变活；
  * 参数：
    * 形参：函数内部的变量，只能在函数内部玩耍；函数的外面不能使用；即使外面的变量和内部的变量同名，也没有任何关系；
    * 实参：实际参与运算的数据，把实参的数据，赋值（复制）了一份给形参；
  * 返回：如何函数里面加工完结果，外面需要，设置返回值 return 数据；
  * 核心：函数把代码分成 里面 和 外面；**里面和外面没有任何关系；**
    * 两座桥：
      * 外面的数据 怎么 进入函数里面？参数；
      * 函数内部的数据怎么 给到函数的外面？返回值；



* 需求：通过函数，把n-m之间所有的数的和，返回给我；
* 步骤：
  * 1.把实际过程写出来。1-10；
  * 2.试着封装函数：
  * 3.是否配置参数？是否设置返回值？

```js
// 需求：通过函数，把n-m之间所有的数的和，返回给我JS；
  // 1. 把实际过程写出来。 1 - 10；
  // var he = 0;
  // for (var i = 1; i < 11; i++) {
  //   he += i;
  // }
  // console.log(he);

  // 2. 试着封装函数：

  // function getHe() {
  //   var he = 0;
  //   for (var i = 1; i < 11; i++) {
  //     he += i;
  //   }
  //   console.log(he);
  // }

  // 3. 是否配置参数？ 是否设置返回值？
  // n~m  1~10
  // 3.1 是否配置参数？配置完形参后，注意一定在小括号写上形参；
  // 3.2 是否设置返回值？
  function getHe(n, m) {
    var he = 0;
    for (var i = n; i <= m; i++) {
      he += i;
    }
    // console.log(he);
    // 返回的是数据
    return he;
  }

  // 测试：
  var a = getHe(20, 22);
  console.log(a);
```





# 07-函数-参数-arguments

```js
  // arguments：解决参数个数不确定；
  // 是什么？函数内部（里面）的变量；只能在函数内部使用；
  // 特点：JS内置的变量，不需要我们声明，也不需要写在小括号内；
  // 语法：arguments把参数传入值，都接受到，生成一个 伪数组；
  //      伪数组：和数组很像，但是不是数组。伪数组有下标，有长度，可遍历；
  // function fn() {
  //   console.log(arguments);
  // }

  // fn(1, 10, 20, 66, 89, 88, 99);
  // Arguments(7) [1, 10, 20, 66, 89, 88, 99, callee: ƒ, Symbol(Symbol.iterator): ƒ]
```

* 使用场景：参数个数不确定的时候；
* split（）
  * 传入：分隔符；
  * 返回：数组；



# 08-函数-函数表达式-匿名函数-了解

```js
// 函数表达式 是另外一种声明的方式
  // var fn_2 = function() {
  //   console.log(1);
  // }
  // fn_2();

  // -----------------------------------------------
  // 匿名函数：函数没有名字；
  // 特点：不能单独使用：
  // function () {
  //   console.log(1);
  // } 报错: Uncaught SyntaxError: Unexpected token (

  // 使用1:函数表达式;
  // 使用2:自调用(自执行)函数；
  // 语法格式：
  // (function() {
  //   console.log("-------------------------");
  // })();
```



# 09-函数-函数类型-回调函数-了解

```js
// function fn() {

  // }
       函数类型：function
  // console.log(typeof fn);


  // --------------------------回调函数；
  function fn(a) {
    a();
  }

  function demo() {
    console.log("我是demo内的代码");
  }
  // demo：function demo() {}
  // 参数：传入的是函数，这个被传入的函数（作为参数）就叫回调函数；
  fn(demo);
  // a = demo;
  // a:function demo() {}
```









# 10-js-作用域

* 作用域：变量、函数生效的范围；
* 全局作用域：在script 里面声明的变量 函数 function 作用域范围：全局作用域；在
* 局部作用域：函数内部声明的变量，只能在函数内部范围，局部作用域；在外面不能访问；

```js
// 全局作用域：在script 里面声明的变量 函数 function 作用域范围：全局作用域；
  // 规则：全局声明的变量，在JS代码 任何位置都可以使用；

  // 局部作用域：函数内部的范围  function fn() { 局部作用域 } 
  // 局部变量：函数内部声明的变量；规则：只能在函数内部使用；


  // 规则1演示：任何位置，包括局部作用域（函数内部）；全局变量可以在函数内部使用；
  // var a = 1;

  // function fn() {
  //   console.log(a);
  // }
  // fn();

  // 规则2演示：函数内部的变量，局部变量，只能在函数内部使用；外面不能使用；Uncaught ReferenceError: a is not defined
  // function fn() {
  //   var a;
  // }
  // console.log(a);
```





# 11-js-预解析-01-基础演示

* 预解析，也叫变量提升：会把声明的变量和函数提升到你当前的作用域的最顶端；
* 注意：你当前的作用域的是在哪？
  * 是全局作用局
  * 还是局部左右域；


* 基础演示：全局作用域

```js
  // 全局作用域
  console.log(a);
  var a = 1;
```

* 全局作用域预解析演示：

```
  // 模拟：内存；
  // 预解析规则：遇到一个新的作用域，声明：var 变量；function fn(){}，提升到当前作用域最顶端；
  // 不执行，只是预解析，把预解析后代码才会执行；
  var a;

  console.log(a); // undefined;
  a = 1;
```

* 基础演示：局部作用域：

```js
  // 局部作用域：函数内部
  function fn() {
    console.log(a);
    var a = 1;
  }

  fn();
```

* 局部作用域的演示：

```js
function fn() {
    var a;
    console.log(a);
    a = 1;
}
// 全局解析完毕，执行函数，进入局部作用域（新的作用域）
fn();
```







# 11-js-预解析-02-面试题

* 基础面试题：

```js
// 观察下面的代码，说出执行结果
var num = 10;
fun();
console.log(num); 

function fun() {
  console.log(num);
  var num = 20;
}
```

* 演示预解析-全局：

```js
var num;

function fun() {
    console.log(num);
    var num = 20;
}
// --------------------
num = 10; // 全局num
fun();
console.log(num); // 全局num 10;
```

* 演示预解析-局部：

```js
// 模拟函数内部：

function fun() {
    var num; // 局部num;
    // ------------------
    console.log(num); // 局部num;  undefined
    num = 20; // 局部num;
}
```





# 12-js-作用域链

* 局部变量的寻找 规则：先在当前自己的作用域的中找有没有声明的变量，如果没有往上层作用域找，如果上层作用域也没有该变量，就报错；





# 13-小娜v2-函数封装

* 函数封装：为了以后，在其他地方可以随时随地的拿过来用；



# 14-总结

- 函数：把一些**复用** 代码 **封装** 起来，在未来 **调用**；
- 需求：函数里面的功能不能写成固定代码；变活；
- 核心：函数把代码分成 里面 和 外面；**里面和外面没有任何关系；**【规则】
- 参数：
  - 形参：函数内部的变量，只能在函数内部玩耍；函数的外面不能使用；即使外面的变量和内部的变量同名，也没有任何关系；
    - 内部的变量形式：形参，函数内部自己声明变量，arguments；
  - 实参：实际参与运算的数据，把实参的数据，赋值（复制）了一份给形参；
- 返回：如果函数里面加工完的结果，外面需要，函数内部设置返回值   return 数据；
- 封装函数：是否搭两座桥？【重点】
  - 外面的数据 怎么 进入函数里面？参数；
  - 函数内部的数据是否需要 给到函数的外面？返回值；
- 作用域：
  - 里面：函数里面，局部作用域，局部的变量只能在局部作用域使用；
  - 外面：函数外面，全局作用域，可以在任意地方使用全局作用域的变量；
- 预解析：【重点】
  - 解析：内存，解析后才执行代码；
  - 规则：代码执行的时候，遇见一个新的作用域，预解析，把遇见的 var 变量；function 函数名(){} ,提升到**当前作用域的最顶端**

















